name: "Base Setup"
description: "Base Setup Actions Used Across Workflows"
inputs:
  python_version:
    description: "The python version"
  node_version:
    description: "The node version"
  dependency_type:
    default: "standard"
    description: "The dependency installation type: standard, pre, minimum"
  pnpm_version:
    default: "latest"
    description: "The pnpm version to use when no pnpm packageManager is pinned"
runs:
  using: "composite"
  steps:
    - name: Set up environment
      shell: bash
      run: |
        set -eux
        PYTHON_VERSION="${{ inputs.python_version || matrix.python-version }}"
        NODE_VERSION=${{ inputs.node_version || matrix.node-version || '24.x' }}
        DEPENDENCY_TYPE=${{ inputs.dependency_type }}

        # Handle default python value based on dependency type.
        if [ $DEPENDENCY_TYPE == "pre" ]; then
          DEFAULT_PYTHON="3.15"
        elif [ $DEPENDENCY_TYPE == "minimum" ]; then
          DEFAULT_PYTHON="3.10"
        elif [ $DEPENDENCY_TYPE != "standard" ]; then
          echo "Unrecognized dependency type $DEPENDENCY_TYPE"
          exit 1
        else
          DEFAULT_PYTHON="3.12"
        fi

        echo "DEFAULT_PYTHON is $DEFAULT_PYTHON"
        PYTHON_VERSION="${PYTHON_VERSION:-$DEFAULT_PYTHON}"

        echo "PYTHON_VERSION=$PYTHON_VERSION" >> $GITHUB_ENV
        echo "NODE_VERSION=$NODE_VERSION" >> $GITHUB_ENV
        echo "CACHE_PREFIX=${{ runner.os }}-${{ github.workflow}}-${{ github.job }}" >> $GITHUB_ENV
        echo "DEPENDENCY_TYPE=$DEPENDENCY_TYPE" >> $GITHUB_ENV

    - name: Install Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        allow-prereleases: true

    # Cache pip
    # We cannot use the builtin cache because it errors out with the files
    # are not present.
    - name: Get pip cache dir
      id: pip-cache
      shell: bash
      run: |
        echo "dir=$(pip cache dir)" >> $GITHUB_OUTPUT
    - name: Cache pip
      uses: actions/cache@v4
      with:
        path: ${{ steps.pip-cache.outputs.dir }}
        key: ${{ env.CACHE_PREFIX }}-pip-${{ env.PYTHON_VERSION }}-${{ hashFiles('setup.cfg', 'setup.py', '**/requirements.txt', '**/pyproject.toml') }}
        restore-keys: |
          ${{ env.CACHE_PREFIX }}-pip-${{ env.PYTHON_VERSION }}

    - name: Detect package manager
      id: detect-pm
      shell: bash
      run: |
        MANAGER=""
        LOCKFILE=""
        ROOT_PM=""
        PNPM_VERSION=""

        if [ -f package.json ]; then
          if grep -q "\"packageManager\"[[:space:]]*:[[:space:]]*\"pnpm@" package.json; then
            ROOT_PM="pnpm"
          elif grep -q "\"packageManager\"[[:space:]]*:[[:space:]]*\"yarn@" package.json; then
            ROOT_PM="yarn"
          elif grep -q "\"packageManager\"[[:space:]]*:[[:space:]]*\"npm@" package.json; then
            ROOT_PM="npm"
          fi
        fi

        # If root packageManager is declared, only honor the matching lockfile for cache setup.
        # Otherwise, fall back to lockfile presence.
        if [ "$ROOT_PM" = "pnpm" ]; then
          if [ -n "$PNPM_HASH" ]; then
            MANAGER="pnpm"
            LOCKFILE="**/pnpm-lock.yaml"
          fi
        elif [ "$ROOT_PM" = "yarn" ]; then
          if [ -n "$YARN_HASH" ]; then
            MANAGER="yarn"
            LOCKFILE="**/yarn.lock"
          fi
        elif [ "$ROOT_PM" = "npm" ]; then
          if [ -n "$NPM_HASH" ]; then
            MANAGER="npm"
            LOCKFILE="**/package-lock.json"
          fi
        elif [ -n "$PNPM_HASH" ]; then
          MANAGER="pnpm"
          LOCKFILE="**/pnpm-lock.yaml"
        elif [ -n "$YARN_HASH" ]; then
          MANAGER="yarn"
          LOCKFILE="**/yarn.lock"
        elif [ -n "$NPM_HASH" ]; then
          MANAGER="npm"
          LOCKFILE="**/package-lock.json"
        fi

        if [ "$MANAGER" = "pnpm" ]; then
          if [ "$ROOT_PM" = "pnpm" ] && [ -f package.json ]; then
            # Extract declared pnpm version (strip optional integrity suffix like +sha512...).
            PNPM_VERSION=$(grep -oE "\"packageManager\"[[:space:]]*:[[:space:]]*\"pnpm@[^\"]+\"" package.json | sed -E 's/.*\"pnpm@([^\"]+)\"/\1/' | sed -E 's/\+.*$//' || true)
          fi
          PNPM_VERSION="${PNPM_VERSION:-${{ inputs.pnpm_version }}}"
        fi

        echo "manager=$MANAGER" >> $GITHUB_OUTPUT
        echo "lockfile=$LOCKFILE" >> $GITHUB_OUTPUT
        echo "pnpm-version=$PNPM_VERSION" >> $GITHUB_OUTPUT
      env:
        PNPM_HASH: ${{ hashFiles('**/pnpm-lock.yaml') }}
        YARN_HASH: ${{ hashFiles('**/yarn.lock') }}
        NPM_HASH: ${{ hashFiles('**/package-lock.json') }}

    - name: Install pnpm
      if: steps.detect-pm.outputs.manager == 'pnpm'
      uses: pnpm/action-setup@v4
      with:
        version: ${{ steps.detect-pm.outputs.pnpm-version }}

    - name: Install node (with cache)
      if: steps.detect-pm.outputs.manager != ''
      uses: actions/setup-node@v6
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: ${{ steps.detect-pm.outputs.manager }}
        cache-dependency-path: ${{ steps.detect-pm.outputs.lockfile }}
        # Disable setup-node's implicit npm caching. We always set caching explicitly.
        package-manager-cache: false

    - name: Install node (without cache)
      if: steps.detect-pm.outputs.manager == ''
      uses: actions/setup-node@v6
      with:
        node-version: ${{ env.NODE_VERSION }}
        package-manager-cache: false

    - name: Enable corepack
      shell: bash
      run: |
        if ! command -v corepack >/dev/null 2>&1; then
          echo "corepack is not available, skipping"
          exit 0
        fi

        # When pnpm is the detected manager, pnpm/action-setup already installed it.
        # Skip corepack to avoid conflicting shims.
        if [ "$DETECTED_MANAGER" = "pnpm" ]; then
          echo "pnpm is managed by pnpm/action-setup, skipping corepack"
          exit 0
        fi

        # Enable corepack if any package.json defines packageManager.
        ENABLE_COREPACK=0
        while IFS= read -r -d '' package_json; do
          if grep -q "\"packageManager\"[[:space:]]*:" "$package_json"; then
            ENABLE_COREPACK=1
            break
          fi
        done < <(find . -name package.json -type f -print0)

        if [ "$ENABLE_COREPACK" -eq 1 ]; then
          corepack enable
        fi
      env:
        DETECTED_MANAGER: ${{ steps.detect-pm.outputs.manager }}

    - name: Cache checked links
      if: ${{ matrix.group == 'link_check' }}
      uses: actions/cache@v4
      with:
        path: ~/.cache/pytest-link-check
        key: ${{ env.CACHE_PREFIX }}-linkcheck-${{ hashFiles('**/*.md', '**/*.rst') }}-links
        restore-keys: |
          ${{ env.CACHE_PREFIX }}-linkcheck-

    - name: Cache conda
      uses: actions/cache@v4
      with:
        path: ~/conda_pkgs_dir
        key: ${{ env.CACHE_PREFIX  }}-conda-${{ env.CACHE_NUMBER }}-${{
          hashFiles('**/environment*.yml') }}
        restore-keys: |
          ${{ env.CACHE_PREFIX }}-conda-

    - name: Enable long paths on Windows
      if: startsWith(runner.os, 'Windows')
      run: Set-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Control\FileSystem -Name LongPathsEnabled -Value 1
      shell: pwsh

    - name: Upgrade packaging dependencies
      shell: bash
      run: |
        set -eux
        echo "::group::Upgrade packaging dependencies"
        python -m pip install --upgrade pip pipx
        if [ "$RUNNER_OS" != "Windows" ]; then
          pipx install hatch --python $(which python)
        else
          pipx install hatch
        fi
        echo "::endgroup::"

    - name: Handle dependency type
      shell: bash
      run: |
        set -eux
        if [ $DEPENDENCY_TYPE == 'pre' ]; then
          echo "PIP_PRE=1" >> $GITHUB_ENV
        elif [ $DEPENDENCY_TYPE == 'minimum' ]; then
          source ${{ github.action_path }}/setup_constraints.sh
        fi

    - name: Print Diagnostics
      shell: bash
      run: |
        set -eux
        echo "::group::env"
        env
        echo "::endgroup::"
        pip debug || true
        echo "::group::piplist"
        pip list || true
        echo "::endgroup::"
        node --version
        npm --version || true
        yarn --version || true
        pnpm --version || true
